# 서든어택 유저 정보 조회

서든어택(SA) 게임 유저의 정보를 조회할 수 있는 웹 애플리케이션입니다. Nexon Open API를 활용하여 유저의 기본 정보, 랭크, 티어, 최근 전적, 매치 상세 정보 등을 조회할 수 있습니다.

## 프로젝트 URL

[프로젝트 방문하기](https://nexon-sa-user.vercel.app/)

## 주요 기능

- **유저 검색**: 닉네임으로 유저 정보 조회
- **유저 정보 조회**:
  - 기본 정보 (레벨, 클랜 등)
  - 랭크 정보
  - 티어 정보
  - 최근 전적 정보
- **매치 정보 조회**:
  - 매치 목록 조회
  - 매치 상세 정보 조회
- **에러 처리**: 전역 에러 바운더리를 통한 안정적인 에러 처리
- **로딩 상태**: Lottie 애니메이션을 활용한 로딩 UI

## 주요 특징

### `useSAUserBundle` Hook

- 사용자 데이터 가져오기와 상태 업데이트를 관리하는 핵심 커스텀 훅
- 효율적인 데이터 패칭을 위해 `react-query`의 `useQuery`와 `useQueries` 활용
- Zustand와 통합하여 전역 상태 관리
- User ID, Basic Info, Rank, Tier, Recent Info 등 여러 API를 순차적으로 호출하여 통합된 데이터 제공
- 로딩 및 에러 상태를 통합 관리
- `useMemo`를 활용한 성능 최적화

### 상태 관리

- **Zustand**를 사용한 전역 상태 관리:
  - `useSA_UserIDStore`: 유저 ID (ouid) 관리
  - `useSA_UserInfoStore`: 유저 정보 (기본 정보, 랭크, 티어, 최근 정보) 관리
  - `useSA_MatchIDStore`: 매치 ID 관리
  - `useSA_MatchInfoStore`: 매치 정보 및 표시 개수 관리

### 에러 처리

- `react-error-boundary`를 활용한 전역 에러 바운더리 구현
- API 에러 전용 에러 바운더리 (`ApiErrorBoundary`)
- 사용자 친화적인 에러 UI 제공

## 프로젝트 구조

```
src/
├── api/
│   ├── bundle/
│   │   └── useSAUserBundle.tsx    # 유저 정보 통합 훅
│   ├── fetch.ts                    # API 호출 함수들
│   └── fetchHooks.tsx              # API 훅들
├── component/
│   ├── card/                       # 카드 컴포넌트들
│   │   ├── MatchCard.tsx
│   │   ├── MatchDetailCard.tsx
│   │   ├── RankCard.tsx
│   │   ├── SA_Card.tsx
│   │   ├── TeamBlock.tsx
│   │   └── TierCard.tsx
│   ├── Home/                       # 홈 페이지 컴포넌트들
│   │   ├── EmptyState.tsx
│   │   ├── HomeContainer.tsx
│   │   ├── MatchContainer.tsx
│   │   ├── Profile.tsx
│   │   └── SearchUser.tsx
│   ├── match/
│   │   └── MatchTags.tsx
│   ├── stat/                       # 통계 컴포넌트들
│   │   ├── RecentStat.tsx
│   │   └── Stat.tsx
│   ├── ApiErrorBoundary.tsx        # API 에러 바운더리
│   ├── ErrorFallback.tsx
│   ├── GlobalErrorBoundary.tsx     # 전역 에러 바운더리
│   └── Skeleton.tsx                # 로딩 스켈레톤
├── lotties/                        # Lottie 애니메이션 파일들
│   ├── error.json
│   ├── loading.json
│   ├── logo.json
│   ├── skill.json
│   ├── splash.json
│   ├── Loading.tsx
│   ├── SplashLoading.tsx
│   └── TopLoading.tsx
├── routes/                         # 라우트 컴포넌트들
│   ├── home/
│   │   └── Home.tsx
│   └── search/
│       └── Search.tsx
├── store/
│   └── data.ts                     # Zustand 스토어 정의
├── util/                           # 유틸리티 함수들
│   ├── cookies.ts
│   ├── server.ts
│   └── type.ts
├── App.tsx                         # 메인 앱 컴포넌트
└── main.tsx                        # 진입점
```

## 설치 및 실행

### 사전 준비

- Node.js (권장 버전: 18 이상)
- npm 또는 yarn

### 설정

1. 레포지토리 클론:

```bash
git clone <repository-url>
cd nexon
```

2. 필요한 패키지 설치:

```bash
npm install
```

3. 환경 변수 설정 (필요한 경우):

프로젝트 루트에 `.env` 파일을 생성하고 Nexon API 키를 설정하세요:

```env
VITE_NEXON_API_KEY=your_api_key_here
VITE_NEXON_API_URL=your_api_url_here
```

### 개발 서버 실행

개발 서버를 시작하려면 다음 명령어를 실행하세요:

```bash
npm run dev
```

브라우저에서 `http://localhost:5173` (또는 표시된 포트)로 접속하세요.

### 프로덕션 빌드

프로덕션용으로 빌드하려면 다음을 실행하세요:

```bash
npm run build
```

빌드된 파일은 `dist` 폴더에 생성됩니다.


## 기술 스택

### 핵심 기술
- **React 18**: 사용자 인터페이스 구축
- **TypeScript**: 타입 안정성
- **Vite**: 빠른 빌드 도구 및 개발 서버

### 상태 관리 및 데이터 페칭
- **Zustand**: 경량 전역 상태 관리
- **React Query (v3)**: 서버 상태 관리 및 데이터 캐싱

### 라우팅
- **React Router DOM**: 클라이언트 사이드 라우팅

### 스타일링
- **Tailwind CSS**: 유틸리티 퍼스트 CSS 프레임워크

### 애니메이션
- **Lottie React**: JSON 기반 애니메이션

### HTTP 클라이언트
- **Axios**: API 요청 처리

### 에러 처리
- **React Error Boundary**: 컴포넌트 에러 처리

### 기타
- **React Icons**: 아이콘 라이브러리
- **React Cookie**: 쿠키 관리
- **React GA4**: Google Analytics 통합

## 배포

이 프로젝트는 **Vercel**에 배포되어 있습니다. `vercel.json` 설정 파일을 통해 라우팅 및 API 프록시 설정이 구성되어 있습니다.

## 배운 점

### 1. 복잡한 데이터 페칭 로직의 구조화

**`useSAUserBundle` 커스텀 훅 개발**을 통해 순차적이고 의존적인 API 호출을 효율적으로 관리하는 방법을 배웠습니다.

- **순차적 API 호출**: 닉네임 → User ID (ouid) → 여러 정보 (Basic, Rank, Tier, Recent) 순서로 호출해야 하는 상황에서 `useQuery`와 `useQueries`를 조합하여 구현했습니다.
- **조건부 쿼리 실행**: `enabled` 옵션을 활용하여 이전 쿼리의 결과에 따라 다음 쿼리를 실행하도록 설계했습니다. 이를 통해 불필요한 API 호출을 방지하고 네트워크 리소스를 절약할 수 있었습니다.
- **통합된 로딩/에러 상태**: 여러 쿼리의 상태를 하나로 통합하여 컴포넌트에서 사용하기 쉽게 만들었습니다. `useMemo`를 활용하여 데이터가 변경될 때만 재계산되도록 최적화했습니다.

이를 통해 **복잡한 비동기 로직을 재사용 가능한 훅으로 추상화**하는 방법을 깊이 이해하게 되었습니다.

### 2. Provider 패턴을 통한 관심사 분리

**`SAUserProvider`와 `SAMatchProvider`**를 구현하면서 관심사 분리와 컴포넌트 재사용성의 중요성을 배웠습니다.

- **데이터 페칭 로직의 캡슐화**: 각 Provider가 자신의 데이터 페칭과 상태 관리를 담당하여, 자식 컴포넌트들은 데이터의 출처를 신경 쓸 필요 없이 Zustand 스토어에서 데이터를 가져오기만 하면 되었습니다.
- **에러 바운더리와의 조합**: Provider를 `ApiErrorBoundary`로 감싸서 각 섹션별로 독립적인 에러 처리가 가능하도록 했습니다. 한 섹션에서 에러가 발생해도 다른 섹션은 정상적으로 동작할 수 있었습니다.
- **조건부 렌더링**: 데이터가 로드되기 전에는 로딩 UI를, 에러 발생 시에는 에러를 throw하여 에러 바운더리가 처리하도록 했습니다.

이 패턴을 통해 **컴포넌트의 책임을 명확히 분리**하고, **테스트와 유지보수가 쉬운 구조**를 만들 수 있었습니다.

### 3. React Query의 고급 활용법

**React Query의 다양한 기능**을 실제 프로젝트에 적용하면서 서버 상태 관리의 강력함을 체감했습니다.

- **쿼리 키 전략**: `["SA_UserId", nickname]`, `["SA_UserBasicInfo", ouid]`처럼 계층적 쿼리 키를 사용하여 캐싱과 무효화를 효율적으로 관리했습니다.
- **staleTime 활용**: 매치 상세 정보 같은 변경이 거의 없는 데이터는 `staleTime: Infinity`로 설정하여 불필요한 재요청을 방지했습니다.
- **조건부 쿼리**: `enabled: open` 옵션을 사용하여 사용자가 "매치 상세 정보 보기" 버튼을 클릭했을 때만 상세 정보를 가져오도록 구현했습니다. 이를 통해 초기 로딩 시간을 단축하고 사용자 경험을 개선했습니다.
- **자동 재시도**: `retry: 3` 옵션으로 일시적인 네트워크 오류에 대한 복원력을 높였습니다.

### 4. Intersection Observer를 활용한 무한 스크롤

**Intersection Observer API**를 직접 구현하면서 성능 최적화와 사용자 경험 개선의 균형을 배웠습니다.

- **점진적 데이터 로딩**: 초기에는 10개의 매치만 표시하고, 사용자가 스크롤하여 트리거 요소에 도달하면 추가로 10개씩 로드하도록 구현했습니다.
- **메모리 효율성**: 모든 데이터를 한 번에 렌더링하지 않고 필요한 만큼만 렌더링하여 메모리 사용량을 최적화했습니다.
- **Observer 정리**: `useEffect`의 cleanup 함수에서 observer를 disconnect하여 메모리 누수를 방지했습니다.

이를 통해 **복잡한 라이브러리 없이도 효율적인 무한 스크롤**을 구현할 수 있다는 자신감을 얻었습니다.

### 5. Zustand를 통한 경량 상태 관리

**Zustand의 단순함과 강력함**을 경험했습니다.

- **보일러플레이트 최소화**: Redux와 달리 action, reducer, dispatch 없이도 간단하게 상태를 관리할 수 있었습니다.
- **타입 안정성**: TypeScript와 함께 사용하면서 타입 안정성을 보장할 수 있었습니다.
- **선택적 구독**: 컴포넌트에서 필요한 스토어만 구독하여 불필요한 리렌더링을 방지했습니다.
- **Provider 불필요**: Context API처럼 Provider로 감쌀 필요 없이 어디서든 스토어를 사용할 수 있어 코드가 더 간결해졌습니다.

특히 **여러 스토어를 분리**하여 (UserID, UserInfo, MatchID, MatchInfo) 각각의 책임을 명확히 한 것이 코드의 가독성과 유지보수성을 크게 향상시켰습니다.

### 6. 에러 바운더리의 계층적 구조

**전역 에러 바운더리와 API 에러 바운더리**를 분리하여 구현하면서 에러 처리 전략의 중요성을 배웠습니다.

- **계층적 에러 처리**: `GlobalErrorBoundary`는 애플리케이션 전체를 감싸고, `ApiErrorBoundary`는 각 데이터 페칭 섹션을 감싸서 세밀한 에러 처리가 가능했습니다.
- **사용자 경험**: 한 섹션에서 에러가 발생해도 다른 섹션은 정상적으로 동작하여 사용자가 다른 정보는 계속 볼 수 있었습니다.
- **에러 복구**: 에러 바운더리의 `onReset` 기능을 통해 사용자가 에러 상태에서 복구할 수 있는 경로를 제공할 수 있었습니다.

### 7. 쿠키를 활용한 사용자 경험 개선

**최근 검색 기능**을 구현하면서 클라이언트 사이드 데이터 저장의 실용성을 배웠습니다.

- **로컬 상태와 동기화**: 쿠키에 저장된 최근 검색 목록을 컴포넌트 마운트 시 로드하여 사용자에게 즉시 표시했습니다.
- **중복 제거 및 순서 관리**: 새로운 검색어를 맨 앞에 추가하고 중복을 제거하여 사용자가 자주 검색하는 항목을 쉽게 찾을 수 있도록 했습니다.
- **세션 유지**: 페이지를 새로고침하거나 나중에 다시 방문해도 최근 검색 목록이 유지되어 사용자 편의성을 높였습니다.

## 느낀 점

### 1. "작은 것부터 시작하라"의 중요성

처음에는 모든 기능을 한 번에 구현하려고 했지만, **하나씩 단계적으로 구현**하면서 각 부분의 동작을 확실히 이해할 수 있었습니다. `useSAUserBundle` 훅도 처음에는 단순한 API 호출이었지만, 점차 로딩 상태, 에러 처리, 메모이제이션 등을 추가하면서 견고한 훅으로 발전시킬 수 있었습니다.

### 2. 사용자 경험을 고려한 설계의 가치

단순히 기능을 구현하는 것이 아니라 **사용자가 어떻게 사용할지**를 고민하면서 개발했습니다. 예를 들어:
- 매치 상세 정보는 클릭했을 때만 로드하여 초기 로딩 시간을 단축
- 무한 스크롤로 한 번에 많은 데이터를 로드하지 않아도 되도록 구현
- 최근 검색 기능으로 사용자의 편의성 향상
- 로딩 애니메이션으로 대기 시간을 지루하지 않게 만듦

이런 세심한 배려가 **실제 사용자에게 큰 차이**를 만든다는 것을 느꼈습니다.

### 3. 코드 구조의 중요성

프로젝트가 커질수록 **코드 구조의 중요성**이 더욱 명확해졌습니다. 
- Provider 패턴으로 관심사 분리
- 컴포넌트를 기능별로 폴더 구조화
- 재사용 가능한 유틸리티 함수 분리
- 타입 정의를 별도 파일로 관리

이런 구조화 작업이 나중에 **버그 수정이나 기능 추가를 훨씬 쉽게** 만들어주었습니다.

### 4. 성능 최적화는 신중하게

성능 최적화도 중요하지만, **과도한 최적화는 오히려 코드를 복잡하게** 만들 수 있다는 것을 배웠습니다. `useMemo`나 `useCallback`을 남발하기보다는, 실제로 성능 문제가 발생하는 부분에만 적용하는 것이 중요했습니다. React Query의 캐싱 기능만으로도 대부분의 성능 문제가 해결되었고, 추가적인 최적화는 정말 필요한 경우에만 적용했습니다.

### 5. 에러 처리는 사용자 경험의 일부

에러는 피할 수 없는 현실입니다. 중요한 것은 **에러가 발생했을 때 사용자에게 어떻게 보여줄지**입니다. 단순히 "에러가 발생했습니다"라는 메시지보다는, Lottie 애니메이션을 활용한 친근한 에러 UI나, 에러가 발생한 섹션만 격리하여 다른 기능은 계속 사용할 수 있도록 하는 것이 사용자 경험을 크게 향상시켰습니다.

### 6. 타입스크립트의 안정성

TypeScript를 사용하면서 **컴파일 타임에 많은 버그를 잡을 수 있었습니다**. 특히 API 응답 데이터의 타입을 정의하고, 유틸리티 함수의 매개변수와 반환값에 타입을 지정하면서 런타임 에러를 크게 줄일 수 있었습니다. 초기 타입 정의에 시간을 투자한 것이 나중에 디버깅 시간을 절약해주었습니다.

### 7. 실전 프로젝트의 학습 효과

이론만 공부하는 것과 실제로 프로젝트를 만들어보는 것의 차이를 크게 느꼈습니다. 실제 API를 호출하고, 사용자 인터페이스를 만들고, 에러를 처리하고, 성능을 최적화하는 과정에서 **책에서 배운 개념들이 실제로 어떻게 작동하는지** 깊이 이해할 수 있었습니다. 특히 React Query와 Zustand 같은 라이브러리는 문서만 읽는 것보다 실제로 사용해보니 훨씬 더 잘 이해할 수 있었습니다.

이 프로젝트를 통해 **프론트엔드 개발의 전반적인 흐름**을 경험하고, **실무에서 필요한 다양한 기술과 패턴**을 학습할 수 있었습니다. 앞으로도 이런 실전 경험을 통해 더욱 성장하고 싶습니다.

